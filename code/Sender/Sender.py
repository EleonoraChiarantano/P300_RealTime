"""Send a multi-channel time-series with proper meta-data to LSL in single samples, from unicorn device or csv file.

Note on online.csv: The first column of the csv file represents the timestamp of each observation.
The entries of column 19 (Flash) are filled with zeros, except at the timestamp corresponding to
a stimulation onset. The entries of column 20 (Target) are filled with zeros, except at the timestamp
corresponding to the flash onset of a Target symbol.
Note that Fz is the reference
"""
import getopt
import os
import signal
import sys

import numpy as np
import pandas
import switch
from pylsl import StreamInfo, StreamOutlet, local_clock, resolve_stream, StreamInlet

UNICORN_PATH = os.path.join("..", "Unicorn")
sys.path.insert(0, UNICORN_PATH)
import UnicornPy

# Constants ----------------------------------------------------------------------------------------------------------------------
DATA_PATH = os.path.join("..", "..", "data", "Datasets")  # csv folder location

# Flags and variables for optional features --------------------------------------------------------------------------------------
REMOVE_REFERENCE = True    # flag to remove reference channel
REFERENCE_COL_N = 4  # column of reference channel in csv - 1

USE_DEVICE = False      # flag to know if used Unicorn or csv file
CSV_FILE = "online.csv"  # dataset file
SRATE_FILE = 128  # Hz
CHANNEL_NAMES_FILE = ["F7", "F3", "F4", "Fz", "F8", "T7", "C3", "Cz", "C4", "T8", "P7", "P3", "Pz", "P4", "P8", "O1", "O2"]

USING_CONSOLE = True    # flag to enable the console control

DEBUG_PRINT = False      # flag to enable verbose prints

if USING_CONSOLE:
    CONSOLE_PATH = os.path.join("..", "Console")
    sys.path.insert(0, CONSOLE_PATH)
    from Console import DEBUG_PRINT  # overwrite the value of these flags with the one inside Console file


# define handler for whenever the application is interrupted (e.g. with ctrl+c)
def sigint_handler():
    sys.stdout.write("\n")
    print('Application interrupted!')
    sys.exit()


def available_devices():
    try:
        # get available device serials
        deviceList = UnicornPy.GetAvailableDevices(True)
        # on Linux True rescan and False check only paired
        # on Windows True for only paired and False for only unpaired

        return deviceList

    except UnicornPy.DeviceException as e:
        print(e)
    except Exception as e:
        print("An unknown error occurred. %s" % e)


def main(argv):
    global USE_DEVICE  # needed since on next line its value can be reset

    # Outlet for the EEG ---------------------------------------------------------------------------------------------------------
    deviceList = available_devices()

    if USING_CONSOLE:
        # setup console (inlet)
        console_streams = resolve_stream('name', 'Console')
        console_inlet = StreamInlet(console_streams[0], recover=False)

        # get which kind of input is used
        msg, timestamp = console_inlet.pull_sample()  # blocking call
        source = msg[0]

        if source in deviceList:
            USE_DEVICE = True
        else:
            USE_DEVICE = False

    if USE_DEVICE:
        if not USING_CONSOLE:  # need to select input from terminal
            if not deviceList == []:
                # print available device serials
                print("Available devices:")
                i = 0
                for device in deviceList:
                    print("#%i %s" % (i, device))
                    i += 1
            else:
                print("No device available!")
                sys.exit(-1)
            valid_source = False
            while not valid_source:
                # request device selection until valid one
                print()
                source = int(input("Select source by ID #"))
                if source < 0 or source > len(deviceList) - 1:
                    print("Index out of range. Please select a valid source")
                    i = 0
                    for device in deviceList:
                        print("#%i %s" % (i, device))
                        i += 1
                else:
                    valid_source = True
            source = deviceList[source]

        device = UnicornPy.Unicorn(source)
        print("Connected to Unicorn!")

        # values for EEG
        srate = 250  # Hz
        name = 'Unicorn'
        type = 'EEG'
        channel_names = ["Fz", "C3", "Cz", "C4", "Pz", "PO7", "Oz", "PO8"]

    else:  # file case, need to change values at beginning if we consider ones generated by Unicorn
        if USING_CONSOLE:
            csv_file = source
        else:
            csv_file = CSV_FILE

        # values for EEG
        srate = SRATE_FILE
        name = 'EGG_csv_file'
        type = 'EEG'
        if REMOVE_REFERENCE:
            CHANNEL_NAMES_FILE.pop(REFERENCE_COL_N - 1)
            channel_names = CHANNEL_NAMES_FILE
        else:
            channel_names = CHANNEL_NAMES_FILE

        # get values from arguments of main if these are given
        help_string = 'Sender.py -n <csv = file.csv> -s <sampling_rate> -c <channel_names = name_1,...,name_n>'
        try:
            opts, args = getopt.getopt(argv, "hn:s:c:", longopts=["csv_file=", "srate=", "channel_names"])
        except getopt.GetoptError:
            print(help_string)
            sys.exit(2)
        for opt, arg in opts:
            if opt == '-h':
                print(help_string)
                sys.exit()
            elif opt in ("-n", "--csv_file") and not USING_CONSOLE:
                csv_file = arg
            elif opt in ("-s", "--srate"):
                srate = float(arg)
            elif opt in ("-c", "--channel_names"):
                channel_names = arg.split(',')
    n_channels = len(channel_names)

    # first create a new stream info. The last value would be the serial
    # number of the device or some other more or less locally unique
    # identifier for the stream as far as available (you could also omit
    # it but interrupted connections wouldn't auto-recover).
    info = StreamInfo(name, type, n_channels, srate, 'float32', 'myuid2424')

    # append some meta-data
    chns = info.desc().append_child("channels")
    for label in channel_names:
        ch = chns.append_child("channel")
        ch.append_child_value("label", label)
        ch.append_child_value("unit", "microvolts")
        ch.append_child_value("type", "EEG")

    # next make an outlet
    outlet_sender = StreamOutlet(info)

    if not USE_DEVICE:
        # Outlet for the markers -----------------------------------------------------------------------------------------------------
        info_mark = StreamInfo('MarkerStream', 'Markers', 1, 0, 'string')
        # info_mark = StreamInfo('Throwaway', 'Text', 1, 0, 'string')  # only uncomment for sync testing
        outlet_marker = StreamOutlet(info_mark)

    # Finish setup console -----------------------------------------------------------------------------------------------------------
    if USING_CONSOLE:
        ''' Continuously sends to the Console a key message ("OK"), to 
        confirm that this process is ready to begin the acquisition
        and wait for a key message ("NEXT") from the Console that will
        arrive when all the interested processes are ready '''
        info_console = StreamInfo('Data', 'Text', 1, 0, 'string')
        outlet_console = StreamOutlet(info_console)

        print("Ready to send data!")

        while True:
            try:
                msg, timestamp = console_inlet.pull_sample(timeout=0)
                outlet_console.push_sample(['OK'])
                if msg is not None and msg[0] == 'NEXT':
                    break
            except ():
                sys.stdout.write("\n")
                sys.exit()

    # Sending data -------------------------------------------------------------------------------------------------------------------
    if not USE_DEVICE:
        # load chosen csv file
        csv_path = os.path.join(DATA_PATH, csv_file)
        if not os.path.exists(csv_path):
            raise FileNotFoundError("chosen file '" + csv_file + "' not found in expected path (" + DATA_PATH + ")")
        else:
            if REMOVE_REFERENCE: # needed only if file containing reference channel
                sig_data = pandas.read_csv(csv_path, header=None, usecols=[i for i in range(REFERENCE_COL_N)] +
                                                                          [k for k in range(REFERENCE_COL_N + 1, n_channels + 4)])
            else:
                sig_data = pandas.read_csv(csv_path, header=None)
            sig_array = sig_data.to_numpy()
            sig_array = sig_array.tolist()
            csv_row_n = len(sig_array)  # total number of rows
            data_idx = 0

            if not USING_CONSOLE:
                input("Press enter after everything is ready!")
                play = True
            else:  # waiting for play command
                stop = False
                pause = False
                while True:
                    try:
                        msg, timestamp = console_inlet.pull_sample(timeout=0)
                        if msg is not None and msg[0] == 'PLAY':
                            if DEBUG_PRINT:
                                print(msg[0])
                            play = True
                            break
                    except ():
                        sys.stdout.write("\n")
                        sys.exit()

            print("Sending data...")
            if DEBUG_PRINT:
                print("")

            sent_samples = 0
            paused_time = 0  # how much time stayed in pause state
            start_pause = 0  # last time it entered in pause state
            reset_required_sample = False
            start_time = local_clock()
            while data_idx != csv_row_n and play:
                if reset_required_sample:  # i.e. if a pause has occurred, in order not to have required_samples depending on pause time
                    reset_required_sample = False
                    paused_time += local_clock() - start_pause
                elapsed_time = local_clock() - start_time - paused_time  # OBS: elapsed_time in play state
                required_samples = int(srate * elapsed_time) - sent_samples  # OBS: in this way simulated chosen srate
                if required_samples > 0:
                    for samp_ix in range(required_samples):
                        row = sig_array[data_idx]
                        if row[n_channels + 1] == 1:  # i.e. a stimulus has occurred
                            if row[n_channels + 2] == 0:
                                outlet_marker.push_sample("F", row[0])  # frequent stimulus
                            else:
                                outlet_marker.push_sample("R", row[0])  # rare stimulus
                        sample = row[1:n_channels + 1]  # take only channels value

                        # now send it
                        outlet_sender.push_sample(sample, row[0])
                        sent_samples += 1
                        if DEBUG_PRINT:
                            print("timestamp: " + str(row[0]))
                            print("sample: " + str(sample))
                            print("======================")
                        else:
                            sys.stdout.write("\rSent {} samples out of {} ({}%)".format(sent_samples, csv_row_n,
                                                                                        int(sent_samples / csv_row_n * 100)))
                            sys.stdout.flush()
                        data_idx += 1
                        if data_idx == csv_row_n:  # reached end of file
                            break
                        if USING_CONSOLE:  # look for messages from console
                            try:
                                msg, timestamp = console_inlet.pull_sample(timeout=0)
                                if msg is not None:
                                    with switch.Switch(msg[0]) as case:
                                        if DEBUG_PRINT:
                                            print(msg[0])
                                        if case("PAUSE"):
                                            start_pause = local_clock()
                                            pause = True
                                            play = False
                                        elif case("QUIT"):
                                            play = False
                            except ():
                                sys.stdout.write("\n")
                                sys.exit()

                            # PAUSE condition
                            # wait until PLAY, STOP or QUIT are pressed
                            while pause:
                                try:
                                    msg, timestamp = console_inlet.pull_sample(timeout=0)
                                    if msg is not None:
                                        with switch.Switch(msg[0]) as case:
                                            if DEBUG_PRINT:
                                                print(msg[0])
                                            if case("PLAY"):
                                                pause = False
                                                play = True
                                                reset_required_sample = True
                                            elif case("STOP"):
                                                pause = False
                                                stop = True
                                            elif case("QUIT"):
                                                pause = False
                                                play = False
                                except ():
                                    sys.stdout.write("\n")
                                    sys.exit()

                            # STOP condition
                            # wait until PLAY or QUIT are pressed
                            while stop:
                                try:
                                    msg, timestamp = console_inlet.pull_sample(timeout=0)
                                    if msg is not None:
                                        with switch.Switch(msg[0]) as case:
                                            if DEBUG_PRINT:
                                                print(msg[0])
                                            if case("PLAY"):
                                                stop = False
                                                play = True
                                                # reinitialized everything
                                                if not DEBUG_PRINT:
                                                    print("")
                                                print("Resetting to start from scratch...", end="")
                                                # sent msg for receiver
                                                outlet_sender.push_sample([0 for _ in range(n_channels)], 0.00001)
                                                # variables initialization
                                                data_idx = 0
                                                sent_samples = 0
                                                paused_time = 0
                                                start_pause = 0
                                                reset_required_sample = False
                                                print("done!")
                                                start_time = local_clock()
                                            elif case("QUIT"):
                                                stop = False
                                                play = False
                                except ():
                                    sys.stdout.write("\n")
                                    sys.exit()

            sys.stdout.write("\n")
            # send final msg to receiver
            outlet_sender.push_sample([0 for _ in range(n_channels)], 0.0)
            if data_idx == csv_row_n:
                print("End of file reached!")
                # wait for console ack or closing input
                if USING_CONSOLE:
                    while True:
                        outlet_console.push_sample(['EOF'])  # inform console eof was reached
                        msg, timestamp = console_inlet.pull_sample(timeout=0)
                        if msg is not None and msg[0] == 'CLOSE_ALL':
                            break
                else:
                    input("Press enter to terminate the program when the plotter has finished!")

            else:
                print("Session ended!")
                # wait for console ack or closing input
                if USING_CONSOLE:
                    while True:
                        msg, timestamp = console_inlet.pull_sample()  # blocking call
                        if msg is not None and msg[0] == 'CLOSE_ALL':
                            break
                else:
                    input("Press enter to terminate the program when the plotter has finished!")

    else:
        # allocate memory for the acquisition buffer
        numberOfAcquiredChannels = device.GetNumberOfAcquiredChannels()
        receiveBufferBufferLength = numberOfAcquiredChannels * 4  # 4 since using float values (4 bytes each)

        try:
            # Acquisition loop.
            # ------------------------------------------------------------------------------------------------------------------------
            # It is possible to see the Acquisition loop Scheme at the following website
            # https://docs.google.com/drawings/d/1moCJ5C9e4kUnWmn8Hs2KV3biz01qmAClKURc8Bh3TK0/edit?usp=sharing
            # ------------------------------------------------------------------------------------------------------------------------
            if not USING_CONSOLE:
                input("Press enter after everything is ready!")
                play = True
            else:  # waiting for play command
                stop = False
                pause = False
                while True:
                    try:
                        msg, timestamp = console_inlet.pull_sample(timeout=0)
                        if msg is not None and msg[0] == 'PLAY':
                            if DEBUG_PRINT:
                                print(msg[0])
                            play = True
                            break
                    except ():
                        sys.stdout.write("\n")
                        sys.exit()

            print("Sending data...")
            if DEBUG_PRINT:
                print("")

            # start data acquisition
            device.StartAcquisition(False)
            print("Data acquisition started!")

            counter_offset = 0
            while play:
                receiveBuffer = bytearray(receiveBufferBufferLength)
                # receives the configured number of samples from the Unicorn device and writes it to the acquisition buffer
                device.GetData(1, receiveBuffer, receiveBufferBufferLength)

                ''' =================== STRUCTURE OF DECODED DATA =====================
                List of 17 elements:
                [0-7] = [Fz, C3, Cz, C4, Pz, PO7, Oz]
                [8-10] = [Accelerometers X, Y, Z]
                [11-13] = [Gyroscope X, Y, Z]  
                [14] = Battery level
                [15] = Counter
                [16] = Validator indicator
                ================================= END ============================== '''
                decoded_data = np.frombuffer(receiveBuffer, dtype=np.float32, count=17)
                del receiveBuffer

                if DEBUG_PRINT:
                    print("decoded_data: " + str(decoded_data))

                # push data to receiver
                eeg_indexes = np.arange(0, 8)  # channels from 0 to 7 (Note: np.arange(a,b) exclude b)
                validator = decoded_data[16]
                counter = int(decoded_data[15])
                sample = np.take(decoded_data, np.hstack(eeg_indexes))
                if validator == 0:  # not valid sample --> not sent
                    if not DEBUG_PRINT:
                        sys.stdout.write("\n")
                    print("\033[1;31;48m" + "Invalid sample!" + "\033[1;37;0m" +  # code to have red print
                          " sample: {}".format(sample))
                    if DEBUG_PRINT:
                        print("")
                else:  # valid sample
                    timestamp = (counter-1-counter_offset)/srate
                    # OBS counter starts from 1, and we don't consider samples acquired during pause (i.e. counter_offset)
                    outlet_sender.push_sample(sample.tolist(), timestamp)
                    if DEBUG_PRINT:
                        print("timestamp: " + str(timestamp))
                        print("sample: " + str(sample))
                        print("======================")
                    else:
                        sys.stdout.write("\rSent sample at {}s".format(timestamp))
                        sys.stdout.flush()

                if USING_CONSOLE:  # look for messages from console
                    try:
                        msg, timestamp = console_inlet.pull_sample(timeout=0)
                        if msg is not None:
                            with switch.Switch(msg[0]) as case:
                                if DEBUG_PRINT:
                                    print(msg[0])
                                if case("PAUSE"):
                                    pause = True
                                    play = False
                                elif case("QUIT"):
                                    play = False
                    except ():
                        sys.stdout.write("\n")
                        sys.exit()

                    # PAUSE condition
                    # wait until PLAY, STOP or QUIT are pressed
                    while pause:
                        receiveBuffer = bytearray(receiveBufferBufferLength)
                        device.GetData(1, receiveBuffer, receiveBufferBufferLength)
                        decoded_data = np.frombuffer(receiveBuffer, dtype=np.float32, count=17)
                        new_counter = decoded_data[15]
                        del receiveBuffer
                        try:
                            msg, timestamp = console_inlet.pull_sample(timeout=0)
                            if msg is not None:
                                with switch.Switch(msg[0]) as case:
                                    if DEBUG_PRINT:
                                        print(msg[0])
                                    if case("PLAY"):
                                        pause = False
                                        play = True
                                        counter_offset += new_counter - counter
                                    elif case("STOP"):
                                        pause = False
                                        stop = True
                                    elif case("QUIT"):
                                        pause = False
                                        play = False
                        except ():
                            sys.stdout.write("\n")
                            sys.exit()

                    # STOP condition
                    # wait until PLAY or QUIT are pressed
                    while stop:
                        try:
                            msg, timestamp = console_inlet.pull_sample(timeout=0)
                            if msg is not None:
                                with switch.Switch(msg[0]) as case:
                                    if DEBUG_PRINT:
                                        print(msg[0])
                                    if case("PLAY"):
                                        stop = False
                                        play = True
                                        # reinitialized everything
                                        if not DEBUG_PRINT:
                                            print("")
                                        print("Resetting to start from scratch...", end="")
                                        counter_offset = 0
                                        device.StopAcquisition()
                                        device.StartAcquisition(False)
                                        # sent msg for receiver
                                        outlet_sender.push_sample([0 for _ in range(n_channels)], 0.00001)
                                        print("done!")
                                    elif case("QUIT"):
                                        stop = False
                                        play = False
                        except ():
                            sys.stdout.write("\n")
                            sys.exit()

            # stop data acquisition
            device.StopAcquisition()
            sys.stdout.write("\n")
            print("Data acquisition stopped!")

        except UnicornPy.DeviceException as e:
            sys.stdout.write("\n")
            print(e)
        except Exception as e:
            sys.stdout.write("\n")
            print("An unknown error occurred! %s" % e)
        finally:
            # close device
            del device
            print("Disconnected from Unicorn!")

        # send final msg to receiver
        outlet_sender.push_sample([0 for _ in range(n_channels)], 0.0)
        # wait for console ack or closing input
        if USING_CONSOLE:
            while True:
                msg, timestamp = console_inlet.pull_sample()  # blocking call
                if msg is not None and msg[0] == 'CLOSE_ALL':
                    break
        else:
            input("Press enter to terminate the program when the plotter has finished!")


if __name__ == '__main__':
    signal.signal(signal.SIGINT, sigint_handler)  # register the signal handler
    main(sys.argv[1:])
