import os
import argparse
from pandas.errors import EmptyDataError
from pandas import read_csv, DataFrame


def csv_merge(date, srate, n_channels):
    """
    Fuses the 3 csv files generated by the receiver into a single one that can be used for offline reproduction of
    the experiment.

    Parameters:
        date (str): The date of the experiment to be processed.
        srate (int): The sample rate of the signal to be processed.
        n_channels (int): Number of considered channels.
    """

    # setup paths for loading and saving files
    OUTPUT_PATH = os.path.join("..", "..", "output", "Recordings", "rec_session_" + date)
    eeg_path = os.path.join(OUTPUT_PATH, 'eeg_session_' + date + '.csv')
    events_path = os.path.join(OUTPUT_PATH, 'evs_session_' + date + '.csv')
    discard_path = os.path.join(OUTPUT_PATH, 'disc_session_' + date + '.csv')

    # load file as pandas DataFrames
    # catch error if there is no file to read for the given date
    discard_flag = True  # initialize flag before check
    try:
        eeg = read_csv(eeg_path, header=None, index_col=False)
    except:
        print("No file was found for the given date.")
    events = read_csv(events_path, header=None, index_col=False)
    try:
        discard = read_csv(discard_path, header=None, index_col=False)
    except EmptyDataError:
        discard_flag = False

    # add 2 zero columns to the frame for the events
    eeg.insert(eeg.shape[1], eeg.shape[1], 0)
    eeg.insert(eeg.shape[1], eeg.shape[1], 0)

    # switch from dataframes to lists for faster access
    eeg = eeg.values.tolist()
    events = events.values.tolist()
    if discard_flag:
        discards = discard.values.tolist()

    # initialize the list for processed data
    compound = []

    # initialize everything necessary for the loop
    event_idx = 0
    discard_idx = 0
    event_flag = True
    win_offset = 0.001

    print('Processing...', end='')

    # go through each row of the eeg file
    for eeg_row in eeg:
        timestamp = eeg_row[0]
        if event_flag:
            event = events[event_idx]
        if discard_flag:
            discard = discards[discard_idx]
        # check if signal is to be discarded
        if discard_flag and discard[0] <= timestamp <= discard[1]:
            if (event[0] - 1 / srate + win_offset) < timestamp < (event[0] + 1 / srate - win_offset):
                event_idx += 1
                # if we have gone through all events, set flag so we don't attempt out-of-index access
                if event_idx == len(events):
                    event_flag = False
            if timestamp == discard[1]:
                discard_idx += 1
                # out-of-index access check (as for events)
                if discard_idx == len(discards):
                    discard_flag = False
            continue
        # when we encounter an event, we set the right values in the last two columns
        elif (event[0] - 1 / srate + win_offset) < timestamp < (event[0] + 1 / srate - win_offset):
            if event[1] == '[\'F\']':
                eeg_row[n_channels + 1] = 1
            elif event[1] == '[\'R\']':
                eeg_row[n_channels + 1] = 1
                eeg_row[n_channels + 2] = 1
            event_idx += 1
            # out-of-index access check (as we did during discard)
            if event_idx == len(events):
                event_flag = False
        compound.append(eeg_row)

    # move back to DataFrames for saving
    compound_df = DataFrame(compound)
    dest_path = os.path.join(OUTPUT_PATH, 'proc_session_' + date + '.csv')
    compound_df.to_csv(dest_path, index=False, header=False)
    print(' done!')


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("exp_date", help="Date of the experiment to be processed", type=str)
    parser.add_argument("sample_rate", help="Sample rate of the signal to be processed", type=int)
    parser.add_argument("n_channels", help="Number of considered channels", type=int)
    args = parser.parse_args()

    csv_merge(args.exp_date, args.sample_rate, args.n_channels)
